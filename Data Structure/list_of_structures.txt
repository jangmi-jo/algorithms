// - Implement all of these Data structures in a language of your choice(I chose Ruby):
// Linked List
// Dynamic array, implemented with a ring buffer (use a statically sized array underneath the hood)
// Hash set
// Hash map (with chaining)
// Binary heap (without decrease-key; know that Fibonacci heaps exist and know their guarantees)
// Binary search tree (doesn’t need to be self-balancing; know that self-balancing trees exist and know their guarantees)
// Prefix tree (a.k.a. trie)
// Suffix tree (don’t worry about compression, just build a dumb version; know that Ukkonen’s algorithm exists and learn its guarantees)
// An object-oriented adjacency list for graphs
// - Implement all of these algorithms in a language of your choice:
// Binary search (implement it both iteratively and recursively)
// Randomized quicksort (pay extra attention to the partition subroutine, as it’s useful in a lot of places)
// Mergesort
// Breadth-first search in a graph
// Depth-first search in a graph (augment it to detect cycles)
// Tree traversals (pre-order, in-order, post-order)
// Topological sort (using Tarjan’s algorithm)
// Dijkstra’s algorithm (without decrease-key)
// Longest common subsequence (using dynamic programming with matrices)
// Knapsack problem (also dynamic programming)
// - Know how to identify and solve backtracking problems. Loads of first technical phone screens on Collab-edit type environments were backtracking problems.
